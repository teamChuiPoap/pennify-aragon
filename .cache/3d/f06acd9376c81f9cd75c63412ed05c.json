{"id":"node_modules/@1hive/radspec/dist/parser/index.js","dependencies":[{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/parser/index.js.map","includedInParent":true,"mtime":1682941398899},{"name":"/home/agevi/chui Organisation/pennify-aragon/package.json","includedInParent":true,"mtime":1682968105152},{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/package.json","includedInParent":true,"mtime":1682941398899}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Parser=void 0,exports.parse=parse;/**\n * @module radspec/parser\n */ /**\n * A token.\n * @typedef {Object} Token\n * @property {string} type The token type\n * @property {*?} value The value of the token\n */ /**\n * An AST node.\n * @typedef {Object} Node\n * @property {string} type The node type\n */ /**\n * An AST.\n * @typedef {Object} AST\n * @property {string} type\n * @property {Array<Node>} body The AST nodes\n */ /**\n * Enum for parser state.\n *\n * @readonly\n * @enum {string}\n */const PARSER_STATE={OK:\"OK\",ERROR:\"ERROR\"};/**\n * Parses a token list into an AST.\n *\n * @class Parser\n * @param {Array<Token>} tokens\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {Array<Token>} tokens\n * @property {number} cursor\n */class Parser{constructor(tokens){this.state=PARSER_STATE.OK,this.tokens=tokens,this.cursor=0}/**\n   * Get the current token and increase the cursor by 1\n   *\n   * @return {Token}\n   */consume(){return this.cursor++,this.tokens[this.cursor-1]}/**\n   * Get the previous token.\n   *\n   * @return {Token}\n   */previous(){return this.tokens[this.cursor-1]}/**\n   * Get the token under the cursor without consuming it.\n   *\n   * @return {Token}\n   */peek(){return this.tokens[this.cursor]}/**\n   * Checks if the type of the next token matches any of the expected types.\n   *\n   * Increases the cursor by 1 if the token matches.\n   *\n   * @param {...string} expected The expected types\n   * @return {boolean} True if the next token matches, otherwise false\n   */matches(){if(this.eof())return!1;for(var _len=arguments.length,expected=Array(_len),_key=0;_key<_len;_key++)expected[_key]=arguments[_key];for(let type of expected)if(this.peek().type===type)return this.cursor++,!0;return!1}/**\n   * Try to parse comparison operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */comparison(astBody){let node=this.addition(astBody);for(;this.matches(\"GREATER\",\"GREATER_EQUAL\",\"LESS\",\"LESS_EQUAL\",\"EQUAL_EQUAL\",\"BANG_EQUAL\");){let operator=this.previous().type,right=this.addition(astBody);node={type:\"ComparisonExpression\",operator,left:node,right}}return this.matches(\"QUESTION_MARK\")&&(node={type:\"TernaryExpression\",predicate:node,left:this.comparison(astBody)},!this.matches(\"COLON\")&&this.report(\"Half-baked ternary (expected colon)\"),node.right=this.comparison(astBody)),this.matches(\"DOUBLE_VERTICAL_BAR\")&&(node={left:node,right:this.comparison(),type:\"DefaultExpression\"}),node}/**\n   * Try to parse arithmetic operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */addition(astBody){let node=this.multiplication(astBody);for(;this.matches(\"MINUS\",\"PLUS\");){let operator=this.previous().type,right=this.multiplication(astBody);node={type:\"BinaryExpression\",operator,left:node,right}}return node}/**\n   * Try to parse binary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */multiplication(astBody){let node=this.power(astBody);for(;this.matches(\"SLASH\",\"STAR\",\"MODULO\");){let operator=this.previous().type,right=this.power(astBody);node={type:\"BinaryExpression\",operator,left:node,right}}return node}/**\n   * Try to parse exponential operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */power(astBody){let node=this.unary(astBody);for(;this.matches(\"POWER\");){let operator=this.previous().type,right=this.unary(astBody);node={type:\"BinaryExpression\",operator,left:node,right}}return node}/**\n   * Try to parse unary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */unary(astBody){if(this.matches(\"BANG\",\"MINUS\")){let operator=this.previous().type,right=this.unary(astBody);return{type:\"UnaryExpression\",operator,right:right}}return this.identifier(astBody)}/**\n   * Try to parse identifiers and call expressions.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */identifier(astBody){let node;if(this.matches(\"IDENTIFIER\")&&(node={type:\"Identifier\",value:this.previous().value}),!node){const previousNode=astBody.length&&astBody[astBody.length-1];previousNode&&(\"Identifier\"===previousNode.type||\"GroupedExpression\"===previousNode.type||\"CallExpression\"===previousNode.type)&&(node=previousNode,astBody.pop())}if(node){for(;this.matches(\"DOT\");){let property=this.consume().value;node={type:\"PropertyAccessExpression\",target:node,property}}return this.matches(\"LEFT_PAREN\")&&(node={type:\"CallExpression\",target:node.target,callee:node.property,inputs:this.functionInputs(astBody),outputs:[]},this.eof()&&this.report(\"Unterminated call expression\"),node.outputs=this.typeList()),node}return this.helper(astBody)}/**\n   * Try to parse helper functions\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */helper(astBody){if(this.matches(\"AT\")){const identifier=this.consume(),name=identifier.value;\"IDENTIFIER\"!==identifier.type&&this.report(`Invalid helper function name '${name}' provided after @`);const node={type:\"HelperFunction\",name:name};return this.matches(\"LEFT_PAREN\")?node.inputs=this.functionInputs(astBody):this.report(`Expected '(' for executing helper function`),node}return this.primary(astBody)}/**\n   * Try to parse primaries (literals).\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */primary(){if(this.matches(\"NUMBER\",\"STRING\",\"HEXADECIMAL\",\"BOOLEAN\")){let type={NUMBER:\"NumberLiteral\",STRING:\"StringLiteral\",HEXADECIMAL:\"BytesLiteral\",BOOLEAN:\"BoolLiteral\"}[this.previous().type];return{type,value:this.previous().value}}if(this.matches(\"LEFT_PAREN\")){let expression;do// Keep munching expressions in the context of the current expression\nexpression=this.comparison(expression?[expression]:[]);while(!this.eof()&&!this.matches(\"RIGHT_PAREN\"));return this.eof()&&this.report(\"Unterminated grouping\"),{type:\"GroupedExpression\",body:expression}}this.report(`Unknown token \"${this.consume().type}\"`)}/**\n   * Try to parse a type.\n   *\n   * @return {string} The type\n   */type(){return this.matches(\"COLON\")||\"TYPE\"===this.peek().type||this.report(`Expected a type, got \"${this.peek().type}\"`),this.consume().value}/**\n   * Try to parse a type list.\n   *\n   * @return {Array<string>} The list of types\n   */typeList(){// We just have a single type\nif(this.matches(\"COLON\")||\"TYPE\"===this.peek().type&&\"LEFT_PAREN\"===this.peek().type||this.report(`Expected a type or a list of types, got \"${this.peek().type}\"`),!this.matches(\"LEFT_PAREN\"))return[{type:this.consume().value,selected:!0}];let typeList=[];for(;!this.eof()&&!this.matches(\"RIGHT_PAREN\");){// Check if the type is preceded by a < to denote\n// that this is the type of the return value we want.\nlet selected=this.matches(\"LESS\");\"TYPE\"===!this.peek().type&&this.report(`Unexpected identifier in type list, expected type, got \"${this.peek().type}\"`),typeList.push({type:this.consume().value,selected}),selected&&!this.matches(\"GREATER\")&&this.report(`Unclosed selected type`),this.matches(\"COMMA\")||\"RIGHT_PAREN\"===this.peek().type||this.report(\"Undelimited parameter type (expected comma delimiter or closing brace)\")}this.eof()&&this.report(`Unclosed type list`);// Verify that at least one type in the type list has been selected\n// as the type of the return value.\n//\n// If no type has been selected, and the number of types in the type\n// list is exactly 1, then we assume that that type should be\n// marked as selected.\nconst hasSelectedTypeInList=!!typeList.find(item=>item.selected);return hasSelectedTypeInList||1!==typeList.length?!hasSelectedTypeInList&&this.report(`Type list has no selected type`):typeList[0].selected=!0,typeList}/**\n   * Try to parse function arguments.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Array<Node>}\n   */functionInputs(astBody){const inputs=[];for(;!this.eof()&&!this.matches(\"RIGHT_PAREN\");){const input=this.comparison(astBody);input.type?this.matches(\"COLON\")&&this.report(`Unexpected type (already inferred type of parameter)`):input.type=this.type(),inputs.push(input),this.matches(\"COMMA\")||\"RIGHT_PAREN\"===this.peek().type||this.report(\"Undelimited parameter type (expected comma delimiter or closing brace)\")}return inputs}/**\n   * Walk all possible paths and try to parse a single node\n   * from the list of tokens.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */walk(astBody){let token=this.peek();if(\"MONOLOGUE\"===token.type)return{type:\"MonologueStatement\",value:this.consume().value};if(\"TICK\"===token.type){let node={type:\"ExpressionStatement\",body:[]};for(this.matches(\"TICK\");!this.eof()&&\"TICK\"!==this.peek().type;)node.body.push(this.walk(node.body));return this.eof()&&this.report(\"Unterminated expression\"),this.matches(\"TICK\"),node}return this.comparison(astBody)}/**\n   * Walks the token list and returns an AST.\n   *\n   * @return {AST} The AST\n   */async parse(){let ast={type:\"Program\",body:[]};for(;!this.eof();)ast.body.push(this.walk(ast.body));return this.state===PARSER_STATE.ERROR?(console.error(`Errors encountered while parsing source`),ast):ast}/**\n   * Returns true if we've reached the end of the token list, otherwise false.\n   *\n   * @return {boolean}\n   */eof(){return this.cursor>=this.tokens.length}/**\n   * Prints an error with location information to `stderr`\n   * and sets the parser state to `PARSER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */report(error){this.state=PARSER_STATE.ERROR,console.error(`Error (${this.cursor}): ${error}`)}}/**\n * Walks token list and returns an AST.\n *\n * @memberof radspec/parser\n * @param  {Array<Token>} tokens\n * @return {AST} The AST\n */exports.Parser=Parser;function parse(tokens){return new Parser(tokens).parse()}\n"},"sourceMaps":{"js":{"version":3,"sources":["../../src/parser/index.js"],"names":["PARSER_STATE","OK","ERROR","Parser","constructor","tokens","state","cursor","consume","previous","peek","matches","eof","expected","type","comparison","astBody","node","addition","operator","right","left","predicate","report","multiplication","power","unary","identifier","value","previousNode","length","pop","property","target","callee","inputs","functionInputs","outputs","typeList","helper","name","primary","NUMBER","STRING","HEXADECIMAL","BOOLEAN","expression","body","selected","push","hasSelectedTypeInList","find","item","input","walk","token","parse","ast","console","error"],"mappings":"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","sourcesContent":["/**\n * @module radspec/parser\n */\n\n/**\n * A token.\n * @typedef {Object} Token\n * @property {string} type The token type\n * @property {*?} value The value of the token\n */\n\n/**\n * An AST node.\n * @typedef {Object} Node\n * @property {string} type The node type\n */\n/**\n * An AST.\n * @typedef {Object} AST\n * @property {string} type\n * @property {Array<Node>} body The AST nodes\n */\n\n/**\n * Enum for parser state.\n *\n * @readonly\n * @enum {string}\n */\nconst PARSER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR'\n}\n\n/**\n * Parses a token list into an AST.\n *\n * @class Parser\n * @param {Array<Token>} tokens\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {Array<Token>} tokens\n * @property {number} cursor\n */\nexport class Parser {\n  constructor (tokens) {\n    this.state = PARSER_STATE.OK\n\n    this.tokens = tokens\n    this.cursor = 0\n  }\n\n  /**\n   * Get the current token and increase the cursor by 1\n   *\n   * @return {Token}\n   */\n  consume () {\n    this.cursor++\n\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the previous token.\n   *\n   * @return {Token}\n   */\n  previous () {\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the token under the cursor without consuming it.\n   *\n   * @return {Token}\n   */\n  peek () {\n    return this.tokens[this.cursor]\n  }\n\n  /**\n   * Checks if the type of the next token matches any of the expected types.\n   *\n   * Increases the cursor by 1 if the token matches.\n   *\n   * @param {...string} expected The expected types\n   * @return {boolean} True if the next token matches, otherwise false\n   */\n  matches (...expected) {\n    if (this.eof()) return false\n    for (let type of expected) {\n      if (this.peek().type === type) {\n        this.cursor++\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Try to parse comparison operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  comparison (astBody) {\n    let node = this.addition(astBody)\n\n    while (this.matches('GREATER', 'GREATER_EQUAL', 'LESS', 'LESS_EQUAL', 'EQUAL_EQUAL', 'BANG_EQUAL')) {\n      let operator = this.previous().type\n      let right = this.addition(astBody)\n      node = {\n        type: 'ComparisonExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    if (this.matches('QUESTION_MARK')) {\n      node = {\n        type: 'TernaryExpression',\n        predicate: node,\n        left: this.comparison(astBody)\n      }\n\n      if (!this.matches('COLON')) {\n        this.report('Half-baked ternary (expected colon)')\n      }\n\n      node.right = this.comparison(astBody)\n    }\n\n    if (this.matches('DOUBLE_VERTICAL_BAR')) {\n      node = {\n        left: node,\n        right: this.comparison(),\n        type: 'DefaultExpression'\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse arithmetic operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  addition (astBody) {\n    let node = this.multiplication(astBody)\n\n    while (this.matches('MINUS', 'PLUS')) {\n      let operator = this.previous().type\n      let right = this.multiplication(astBody)\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse binary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  multiplication (astBody) {\n    let node = this.power(astBody)\n\n    while (this.matches('SLASH', 'STAR', 'MODULO')) {\n      let operator = this.previous().type\n      let right = this.power(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse exponential operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  power (astBody) {\n    let node = this.unary(astBody)\n\n    while (this.matches('POWER')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse unary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  unary (astBody) {\n    if (this.matches('BANG', 'MINUS')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      return {\n        type: 'UnaryExpression',\n        operator,\n        right: right\n      }\n    }\n\n    return this.identifier(astBody)\n  }\n\n  /**\n   * Try to parse identifiers and call expressions.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  identifier (astBody) {\n    let node\n\n    if (this.matches('IDENTIFIER')) {\n      node = {\n        type: 'Identifier',\n        value: this.previous().value\n      }\n    }\n\n    if (!node) {\n      const previousNode = astBody.length && astBody[astBody.length - 1]\n      if (previousNode && (\n        previousNode.type === 'Identifier' ||\n        previousNode.type === 'GroupedExpression' ||\n        previousNode.type === 'CallExpression'\n      )) {\n        node = previousNode\n        // Consume the last node as part of this node\n        astBody.pop()\n      }\n    }\n\n    if (node) {\n      while (this.matches('DOT')) {\n        let property = this.consume().value\n\n        node = {\n          type: 'PropertyAccessExpression',\n          target: node,\n          property\n        }\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node = {\n          type: 'CallExpression',\n          target: node.target,\n          callee: node.property,\n          inputs: this.functionInputs(astBody),\n          outputs: []\n        }\n\n        if (this.eof()) {\n          // TODO Better error\n          this.report('Unterminated call expression')\n        }\n\n        node.outputs = this.typeList()\n      }\n\n      return node\n    }\n\n    return this.helper(astBody)\n  }\n\n  /**\n   * Try to parse helper functions\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  helper (astBody) {\n    if (this.matches('AT')) {\n      const identifier = this.consume()\n      const name = identifier.value\n\n      if (identifier.type !== 'IDENTIFIER') {\n        this.report(`Invalid helper function name '${name}' provided after @`)\n      }\n\n      const node = {\n        type: 'HelperFunction',\n        name: name\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node.inputs = this.functionInputs(astBody)\n      } else {\n        this.report(`Expected '(' for executing helper function`)\n      }\n\n      return node\n    }\n\n    return this.primary(astBody)\n  }\n\n  /**\n   * Try to parse primaries (literals).\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  primary (astBody) {\n    if (this.matches('NUMBER', 'STRING', 'HEXADECIMAL', 'BOOLEAN')) {\n      let type = {\n        NUMBER: 'NumberLiteral',\n        STRING: 'StringLiteral',\n        HEXADECIMAL: 'BytesLiteral',\n        BOOLEAN: 'BoolLiteral'\n      }[this.previous().type]\n\n      return {\n        type,\n        value: this.previous().value\n      }\n    }\n\n    if (this.matches('LEFT_PAREN')) {\n      let expression\n\n      do {\n        // Keep munching expressions in the context of the current expression\n        expression = this.comparison(expression ? [expression] : [])\n      } while (!this.eof() && !this.matches('RIGHT_PAREN'))\n\n      if (this.eof()) {\n        this.report('Unterminated grouping')\n      }\n\n      return {\n        type: 'GroupedExpression',\n        body: expression\n      }\n    }\n\n    this.report(`Unknown token \"${this.consume().type}\"`)\n  }\n\n  /**\n   * Try to parse a type.\n   *\n   * @return {string} The type\n   */\n  type () {\n    if (!this.matches('COLON') &&\n      this.peek().type !== 'TYPE') {\n      // TODO Better error\n      this.report(`Expected a type, got \"${this.peek().type}\"`)\n    }\n\n    return this.consume().value\n  }\n\n  /**\n   * Try to parse a type list.\n   *\n   * @return {Array<string>} The list of types\n   */\n  typeList () {\n    if (!this.matches('COLON') &&\n      (this.peek().type !== 'TYPE' || this.peek().type !== 'LEFT_PAREN')) {\n      // TODO Better error\n      this.report(`Expected a type or a list of types, got \"${this.peek().type}\"`)\n    }\n\n    // We just have a single type\n    if (!this.matches('LEFT_PAREN')) {\n      return [{\n        type: this.consume().value,\n        selected: true\n      }]\n    }\n\n    let typeList = []\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      // Check if the type is preceded by a < to denote\n      // that this is the type of the return value we want.\n      let selected = this.matches('LESS')\n      if (!this.peek().type === 'TYPE') {\n        this.report(`Unexpected identifier in type list, expected type, got \"${this.peek().type}\"`)\n      }\n\n      typeList.push({\n        type: this.consume().value,\n        selected\n      })\n\n      // If the type was preceded by a <, then it\n      // should be followed by a >.\n      if (selected && !this.matches('GREATER')) {\n        this.report(`Unclosed selected type`)\n      }\n\n      // If this is true, then types have been specified without delimiting them using commas.\n      if (!this.matches('COMMA') && this.peek().type !== 'RIGHT_PAREN') {\n        this.report('Undelimited parameter type (expected comma delimiter or closing brace)')\n      }\n    }\n\n    if (this.eof()) {\n      // TODO Better error\n      this.report(`Unclosed type list`)\n    }\n\n    // Verify that at least one type in the type list has been selected\n    // as the type of the return value.\n    //\n    // If no type has been selected, and the number of types in the type\n    // list is exactly 1, then we assume that that type should be\n    // marked as selected.\n    const hasSelectedTypeInList = !!typeList.find((item) => item.selected)\n    if (!hasSelectedTypeInList && typeList.length === 1) {\n      typeList[0].selected = true\n    } else if (!hasSelectedTypeInList) {\n      this.report(`Type list has no selected type`)\n    }\n\n    return typeList\n  }\n\n  /**\n   * Try to parse function arguments.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Array<Node>}\n   */\n  functionInputs (astBody) {\n    const inputs = []\n\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      const input = this.comparison(astBody)\n      if (!input.type) {\n        input.type = this.type()\n      } else if (this.matches('COLON')) {\n        this.report(`Unexpected type (already inferred type of parameter)`)\n      }\n\n      inputs.push(input)\n\n      // If this is true, then types have been specified without delimiting them using commas.\n      if (!this.matches('COMMA') && this.peek().type !== 'RIGHT_PAREN') {\n        this.report('Undelimited parameter type (expected comma delimiter or closing brace)')\n      }\n    }\n\n    return inputs\n  }\n\n  /**\n   * Walk all possible paths and try to parse a single node\n   * from the list of tokens.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  walk (astBody) {\n    let token = this.peek()\n\n    if (token.type === 'MONOLOGUE') {\n      return {\n        type: 'MonologueStatement',\n        value: this.consume().value\n      }\n    }\n\n    if (token.type === 'TICK') {\n      let node = {\n        type: 'ExpressionStatement',\n        body: []\n      }\n\n      this.matches('TICK')\n\n      while (!this.eof() && this.peek().type !== 'TICK') {\n        node.body.push(this.walk(node.body))\n      }\n\n      if (this.eof()) {\n        this.report('Unterminated expression')\n      }\n\n      this.matches('TICK')\n\n      return node\n    }\n\n    return this.comparison(astBody)\n  }\n\n  /**\n   * Walks the token list and returns an AST.\n   *\n   * @return {AST} The AST\n   */\n  async parse () {\n    let ast = {\n      type: 'Program',\n      body: []\n    }\n\n    while (!this.eof()) {\n      ast.body.push(this.walk(ast.body))\n    }\n\n    if (this.state === PARSER_STATE.ERROR) {\n      console.error(`Errors encountered while parsing source`)\n      return ast\n    }\n\n    return ast\n  }\n\n  /**\n   * Returns true if we've reached the end of the token list, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof () {\n    return this.cursor >= this.tokens.length\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the parser state to `PARSER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report (error) {\n    this.state = PARSER_STATE.ERROR\n    console.error(\n      `Error (${this.cursor}): ${error}`\n    )\n  }\n}\n\n/**\n * Walks token list and returns an AST.\n *\n * @memberof radspec/parser\n * @param  {Array<Token>} tokens\n * @return {AST} The AST\n */\nexport function parse (tokens) {\n  return new Parser(tokens).parse()\n}\n"],"file":"index.js"}},"error":null,"hash":"3b13da412b7b00610fc78c0edb9ae687","cacheData":{"env":{}}}