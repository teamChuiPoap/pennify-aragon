{"id":"node_modules/@1hive/radspec/dist/helpers/radspec.js","dependencies":[{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js.map","includedInParent":true,"mtime":1682941398899},{"name":"/home/agevi/chui Organisation/pennify-aragon/package.json","includedInParent":true,"mtime":1682968105152},{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/package.json","includedInParent":true,"mtime":1682941398899},{"name":"@babel/runtime/helpers/interopRequireDefault","loc":{"line":1,"column":48,"index":48},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@babel/runtime/helpers/interopRequireDefault.js"},{"name":"@babel/runtime/helpers/defineProperty","loc":{"line":1,"column":226,"index":226},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@babel/runtime/helpers/defineProperty.js"},{"name":"ethers","loc":{"line":1,"column":284,"index":284},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/ethers/lib.esm/index.js"},{"name":"./lib/methodRegistry","loc":{"line":1,"column":341,"index":341},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/lib/methodRegistry.js"},{"name":"../lib/","loc":{"line":1,"column":379,"index":379},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/lib/index.js"},{"name":"../defaults","loc":{"line":1,"column":408,"index":408},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/radspec.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/defaults.js"}],"generated":{"js":"\"use strict\";var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var _defineProperty2=_interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\")),_ethers=require(\"ethers\"),_methodRegistry=_interopRequireDefault(require(\"./lib/methodRegistry\")),_lib=require(\"../lib/\"),_defaults=require(\"../defaults\");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}const makeUnknownFunctionNode=methodId=>({type:\"string\",value:`Unknown function (${methodId})`}),parse=signature=>{const fragment=_ethers.utils.FunctionFragment.from(signature);return{name:fragment.name.charAt(0).toUpperCase()+fragment.name.slice(1).split(/(?=[A-Z])/).join(\" \"),args:fragment.inputs.map(input=>({type:input.type}))}},getSigHah=sig=>_ethers.utils.hexDataSlice(_ethers.utils.id(sig),0,4),processFunctions=functions=>Object.keys(functions).reduce((acc,key)=>{const fragment=_ethers.utils.FunctionFragment.from(key);return _objectSpread({[getSigHah(fragment.format())]:{source:functions[key],fragment}},acc)},{});var _default=(provider,evaluator,functions)=>/**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry and finally using 4bytes API\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @param {string} [registryAddress] The registry address to lookup descriptions\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */async(addr,data,registryAddress)=>{const processedFunctions=processFunctions(functions);if(10>data.length)return makeUnknownFunctionNode(data);// Get method ID\nconst methodId=data.substr(0,10),fn=processedFunctions[methodId];// If function is not a known function\nif(!fn)try{// Try checking on-chain signature registry\nconst registry=new _methodRegistry.default({registryAddress,provider,network:registryAddress?void 0:1// We hardcode the chainId because there is only a single registy\n// (await provider.getNetwork()).chainId\n}),result=await registry.lookup(methodId),{name}=parse(result);return{type:\"string\",value:name// TODO: should we decode and print the arguments as well?\n}}catch{try{// Try fetching 4bytes API\nconst{results}=await _ethers.utils.fetchJson({url:`${_defaults.DEFAULT_API_4BYTES}?hex_signature=${methodId}`,timeout:3e3});if(Array.isArray(results)&&0<results.length){const{name}=parse(results[0].text_signature);return{type:\"string\",value:name}}}catch{// Fallback to unknown function\nreturn makeUnknownFunctionNode(methodId)}}// If the function was found in local radspec registry. Decode and evaluate.\nconst{source,fragment}=fn,ethersInterface=new _ethers.utils.Interface([fragment]),args=ethersInterface.decodeFunctionData(fragment.name,data),parameters=fragment.inputs.reduce((parameters,input,index)=>_objectSpread({[`$${index+1}`]:{type:input.type,value:args[index]}},parameters),{});return{type:\"string\",value:await(0,_lib.evaluateRaw)(source,parameters,{provider,availableHelpers:evaluator.helpers.getHelpers(),availableFunctions:functions,to:addr})}};exports.default=_default;\n"},"sourceMaps":{"js":{"version":3,"sources":["../../src/helpers/radspec.js"],"names":["makeUnknownFunctionNode","methodId","type","value","parse","signature","fragment","ethersUtils","FunctionFragment","from","name","charAt","toUpperCase","slice","split","join","args","inputs","map","input","getSigHah","sig","hexDataSlice","id","processFunctions","functions","Object","keys","reduce","acc","key","format","source","provider","evaluator","addr","data","registryAddress","processedFunctions","length","substr","fn","registry","MethodRegistry","network","result","lookup","results","fetchJson","url","DEFAULT_API_4BYTES","timeout","Array","isArray","text_signature","ethersInterface","Interface","decodeFunctionData","parameters","index","availableHelpers","helpers","getHelpers","availableFunctions","to"],"mappings":"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","sourcesContent":["import { utils as ethersUtils } from 'ethers'\n\nimport MethodRegistry from './lib/methodRegistry'\nimport { evaluateRaw } from '../lib/'\nimport { DEFAULT_API_4BYTES } from '../defaults'\n\nconst makeUnknownFunctionNode = (methodId) => ({\n  type: 'string',\n  value: `Unknown function (${methodId})`\n})\n\nconst parse = (signature) => {\n  const fragment = ethersUtils.FunctionFragment.from(signature)\n\n  return {\n    name:\n      fragment.name.charAt(0).toUpperCase() +\n      fragment.name\n        .slice(1)\n        .split(/(?=[A-Z])/)\n        .join(' '),\n    args: fragment.inputs.map((input) => {\n      return { type: input.type }\n    })\n  }\n}\n\n// Hash signature with Ethereum Identity and silce bytes\nconst getSigHah = (sig) => ethersUtils.hexDataSlice(ethersUtils.id(sig), 0, 4)\n\n// Convert from the knownFunctions data format into the needed format\n// Input: { \"signature(type1,type2)\": \"Its radspec string\", ... }\n// Output: { \"0xabcdef12\": { \"fragment\": FunctionFragment, \"source\": \"Its radspec string\" }, ...}\nconst processFunctions = (functions) =>\n  Object.keys(functions).reduce((acc, key) => {\n    const fragment = ethersUtils.FunctionFragment.from(key)\n    return {\n      [getSigHah(fragment.format())]: { source: functions[key], fragment },\n      ...acc\n    }\n  }, {})\n\nexport default (provider, evaluator, functions) =>\n  /**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry and finally using 4bytes API\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @param {string} [registryAddress] The registry address to lookup descriptions\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (addr, data, registryAddress) => {\n    const processedFunctions = processFunctions(functions)\n\n    if (data.length < 10) {\n      return makeUnknownFunctionNode(data)\n    }\n\n    // Get method ID\n    const methodId = data.substr(0, 10)\n    const fn = processedFunctions[methodId]\n\n    // If function is not a known function\n    if (!fn) {\n      try {\n        // Try checking on-chain signature registry\n        const registry = new MethodRegistry({\n          registryAddress,\n          provider,\n          network: registryAddress\n            ? undefined\n            : 1 // We hardcode the chainId because there is only a single registy\n                // (await provider.getNetwork()).chainId\n        })\n        const result = await registry.lookup(methodId)\n        const { name } = parse(result)\n        return {\n          type: 'string',\n          value: name // TODO: should we decode and print the arguments as well?\n        }\n      } catch {\n        try {\n        // Try fetching 4bytes API\n          const { results } = await ethersUtils.fetchJson({\n            url: `${DEFAULT_API_4BYTES}?hex_signature=${methodId}`,\n            timeout: 3000\n          })\n          if (Array.isArray(results) && results.length > 0) {\n            const { name } = parse(results[0].text_signature)\n            return {\n              type: 'string',\n              value: name\n            }\n          }\n        } catch {\n          // Fallback to unknown function\n          return makeUnknownFunctionNode(methodId)\n        }\n      }\n    }\n    // If the function was found in local radspec registry. Decode and evaluate.\n    const { source, fragment } = fn\n\n    const ethersInterface = new ethersUtils.Interface([fragment])\n\n    // Decode parameters\n    const args = ethersInterface.decodeFunctionData(fragment.name, data)\n\n    const parameters = fragment.inputs.reduce(\n      (parameters, input, index) => ({\n        [`$${index + 1}`]: {\n          type: input.type,\n          value: args[index]\n        },\n        ...parameters\n      }),\n      {}\n    )\n\n    return {\n      type: 'string',\n      value: await evaluateRaw(source, parameters, {\n        provider,\n        availableHelpers: evaluator.helpers.getHelpers(),\n        availableFunctions: functions,\n        to: addr\n      })\n    }\n  }\n"],"file":"radspec.js"}},"error":null,"hash":"90baabcea3397a17645fe7674a9be6eb","cacheData":{"env":{}}}