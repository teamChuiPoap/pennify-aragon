{"id":"node_modules/@1hive/radspec/dist/scanner/index.js","dependencies":[{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/scanner/index.js.map","includedInParent":true,"mtime":1682941398899},{"name":"/home/agevi/chui Organisation/pennify-aragon/package.json","includedInParent":true,"mtime":1682968105152},{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/package.json","includedInParent":true,"mtime":1682941398899},{"name":"@babel/runtime/helpers/interopRequireDefault","loc":{"line":1,"column":48,"index":48},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/scanner/index.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@babel/runtime/helpers/interopRequireDefault.js"},{"name":"../types","loc":{"line":1,"column":138,"index":138},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/scanner/index.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/types/index.js"}],"generated":{"js":"\"use strict\";var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");var _types=_interopRequireDefault(require(\"../types\"));Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Scanner=void 0,exports.scan=scan;/**\n * @module radspec/scanner\n */ /**\n * Enum for scanner state.\n *\n * @readonly\n * @enum {string}\n */const SCANNER_STATE={OK:\"OK\",ERROR:\"ERROR\"};/**\n * A scanner that identifies tokens in a source string.\n *\n * @class Scanner\n * @param {string} source The source code\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {string} source The source code\n * @property {number} cursor\n * @property {Array<Token>} tokens The currently identified tokens\n */class Scanner{constructor(source){this.state=SCANNER_STATE.OK,this.isInExpression=!1,this.source=source,this.cursor=0,this.tokens=[]}/**\n   * Scans a single token from source and pushes it to `Scanner.tokens`.\n   *\n   * @return {void}\n   */scanToken(){const current=this.consume();if(\"`\"===current)return this.isInExpression=!this.isInExpression,void this.emitToken(\"TICK\");// We haven't hit a tick yet, so we're not in an expression\nif(!this.isInExpression){// Scan until tick\nlet monologue=current;for(;\"`\"!==this.peek()&&!this.eof();)monologue+=this.consume();return void this.emitToken(\"MONOLOGUE\",monologue)}switch(current){// Single character tokens\ncase\"(\":this.emitToken(\"LEFT_PAREN\");break;case\")\":this.emitToken(\"RIGHT_PAREN\");break;case\",\":this.emitToken(\"COMMA\");break;case\".\":this.emitToken(\"DOT\");break;case\":\":this.emitToken(\"COLON\");break;case\"-\":this.emitToken(\"MINUS\");break;case\"+\":this.emitToken(\"PLUS\");break;case\"^\":this.emitToken(\"POWER\");break;case\"*\":this.emitToken(\"STAR\");break;case\"/\":this.emitToken(\"SLASH\");break;case\"%\":this.emitToken(\"MODULO\");break;case\"?\":this.emitToken(\"QUESTION_MARK\");break;case\"@\":this.emitToken(\"AT\");break;// One or two character tokens\ncase\"!\":this.emitToken(this.matches(\"=\")?\"BANG_EQUAL\":\"BANG\");break;case\"=\":this.emitToken(this.matches(\"=\")?\"EQUAL_EQUAL\":\"EQUAL\");break;case\"<\":this.emitToken(this.matches(\"=\")?\"LESS_EQUAL\":\"LESS\");break;case\">\":this.emitToken(this.matches(\"=\")?\"GREATER_EQUAL\":\"GREATER\");break;// Two character tokens\ncase\"|\":this.matches(\"|\")?this.emitToken(\"DOUBLE_VERTICAL_BAR\"):this.report(`Unexpected single \"|\" (expecting two)`);break;// Whitespace\ncase\" \":case\"\\r\":case\"\\n\":case\"\\t\":break;// Multi-character tokens\ndefault:const NUMBERS=/[0-9]/;if(NUMBERS.test(current)){let number=current,type=\"NUMBER\";// Detect hexadecimals\nif(\"0\"===current&&\"x\"===this.peek())for(type=\"HEXADECIMAL\",number+=this.consume();/[0-9a-f]/i.test(this.peek());)number+=this.consume();else for(;NUMBERS.test(this.peek());)number+=this.consume();this.emitToken(type,number);break}const IDENTIFIERS=/[_$a-z0-9]/i;if(IDENTIFIERS.test(current)){let identifier=current;for(;IDENTIFIERS.test(this.peek());)identifier+=this.consume();if(\"true\"===identifier||\"false\"===identifier){this.emitToken(\"BOOLEAN\",identifier);break}_types.default.isType(identifier)?this.emitToken(\"TYPE\",identifier):this.emitToken(\"IDENTIFIER\",identifier);break}if(`'`===current||`\"`===current){let string=\"\";for(;!this.matches(`'`)&&!this.matches(`\"`);)string+=this.consume();this.emitToken(\"STRING\",string);break}this.report(`Unexpected character \"${current}\"`);}}/**\n   * Push a token to `Scanner.tokens`\n   *\n   * @param {string} type The token type\n   * @param {string?} value The token value\n   * @return {void}\n   */emitToken(type,value){let token={type};value&&(token.value=value),this.tokens.push(token)}/**\n   * Get the current character and increase the cursor by 1\n   *\n   * @return {string}\n   */consume(){return this.cursor++,this.source[this.cursor-1]}/**\n   * Get the character under the cursor without consuming it.\n   *\n   * @return {string}\n   */peek(){return this.source[this.cursor]}/**\n   * Checks if the next character matches an expected one.\n   *\n   * Increases the cursor by 1 if the character matches.\n   *\n   * @param {string} expected The character to expect\n   * @return {boolean} True if the next character matches, otherise false\n   */matches(expected){return!this.eof()&&!(this.peek()!==expected)&&(this.cursor++,!0)}/**\n   * Scans source and returns a list of tokens.\n   *\n   * @return {Array<Token>}\n   */async scan(){for(;!this.eof();)this.scanToken();return this.state===SCANNER_STATE.ERROR?void console.error(`Errors encountered while scanning source`):this.tokens}/**\n   * Returns true if we've reached the end of source, otherwise false.\n   *\n   * @return {boolean}\n   */eof(){return this.cursor>=this.source.length}/**\n   * Prints an error with location information to `stderr`\n   * and sets the scanner state to `SCANNER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */report(error){this.state=SCANNER_STATE.ERROR,console.error(`Error (${this.cursor}): ${error}`)}}/**\n * Scans source and returns a list of tokens.\n *\n * @memberof radspec/scanner\n * @param  {string} source\n * @return {Array<Token>}\n */exports.Scanner=Scanner;function scan(source){return new Scanner(source).scan()}\n"},"sourceMaps":{"js":{"version":3,"sources":["../../src/scanner/index.js"],"names":["SCANNER_STATE","OK","ERROR","Scanner","constructor","source","state","isInExpression","cursor","tokens","scanToken","current","consume","emitToken","monologue","peek","eof","matches","report","NUMBERS","test","number","type","IDENTIFIERS","identifier","types","isType","string","value","token","push","expected","scan","console","error","length"],"mappings":"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","sourcesContent":["/**\n * @module radspec/scanner\n */\nimport types from '../types'\n\n/**\n * Enum for scanner state.\n *\n * @readonly\n * @enum {string}\n */\nconst SCANNER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR'\n}\n\n/**\n * A scanner that identifies tokens in a source string.\n *\n * @class Scanner\n * @param {string} source The source code\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {string} source The source code\n * @property {number} cursor\n * @property {Array<Token>} tokens The currently identified tokens\n */\nexport class Scanner {\n  constructor (source) {\n    this.state = SCANNER_STATE.OK\n    this.isInExpression = false\n\n    this.source = source\n    this.cursor = 0\n\n    this.tokens = []\n  }\n\n  /**\n   * Scans a single token from source and pushes it to `Scanner.tokens`.\n   *\n   * @return {void}\n   */\n  scanToken () {\n    const current = this.consume()\n\n    if (current === '`') {\n      this.isInExpression = !this.isInExpression\n      this.emitToken('TICK')\n      return\n    }\n\n    // We haven't hit a tick yet, so we're not in an expression\n    if (!this.isInExpression) {\n      // Scan until tick\n      let monologue = current\n      while (this.peek() !== '`' && !this.eof()) {\n        monologue += this.consume()\n      }\n      this.emitToken('MONOLOGUE', monologue)\n      return\n    }\n\n    switch (current) {\n      // Single character tokens\n      case '(':\n        this.emitToken('LEFT_PAREN')\n        break\n      case ')':\n        this.emitToken('RIGHT_PAREN')\n        break\n      case ',':\n        this.emitToken('COMMA')\n        break\n      case '.':\n        this.emitToken('DOT')\n        break\n      case ':':\n        this.emitToken('COLON')\n        break\n      case '-':\n        this.emitToken('MINUS')\n        break\n      case '+':\n        this.emitToken('PLUS')\n        break\n      case '^':\n        this.emitToken('POWER')\n        break\n      case '*':\n        this.emitToken('STAR')\n        break\n      case '/':\n        this.emitToken('SLASH')\n        break\n      case '%':\n        this.emitToken('MODULO')\n        break\n      case '?':\n        this.emitToken('QUESTION_MARK')\n        break\n      case '@':\n        this.emitToken('AT')\n        break\n\n      // One or two character tokens\n      case '!':\n        this.emitToken(this.matches('=') ? 'BANG_EQUAL' : 'BANG')\n        break\n      case '=':\n        this.emitToken(this.matches('=') ? 'EQUAL_EQUAL' : 'EQUAL')\n        break\n      case '<':\n        this.emitToken(this.matches('=') ? 'LESS_EQUAL' : 'LESS')\n        break\n      case '>':\n        this.emitToken(this.matches('=') ? 'GREATER_EQUAL' : 'GREATER')\n        break\n\n      // Two character tokens\n      case '|':\n        if (this.matches('|')) {\n          this.emitToken('DOUBLE_VERTICAL_BAR')\n        } else {\n          this.report(`Unexpected single \"|\" (expecting two)`)\n        }\n        break\n\n      // Whitespace\n      case ' ':\n      case '\\r':\n      case '\\n':\n      case '\\t':\n        break\n\n      // Multi-character tokens\n      default:\n        const NUMBERS = /[0-9]/\n        const HEX = /[0-9a-f]/i\n        if (NUMBERS.test(current)) {\n          let number = current\n          let type = 'NUMBER'\n\n          // Detect hexadecimals\n          if (current === '0' &&\n            this.peek() === 'x') {\n            type = 'HEXADECIMAL'\n            number += this.consume()\n\n            while (HEX.test(this.peek())) {\n              number += this.consume()\n            }\n          } else {\n            while (NUMBERS.test(this.peek())) {\n              number += this.consume()\n            }\n          }\n\n          this.emitToken(type, number)\n          break\n        }\n\n        const IDENTIFIERS = /[_$a-z0-9]/i\n        if (IDENTIFIERS.test(current)) {\n          let identifier = current\n          while (IDENTIFIERS.test(this.peek())) {\n            identifier += this.consume()\n          }\n\n          if (identifier === 'true' || identifier === 'false') {\n            this.emitToken('BOOLEAN', identifier)\n            break\n          }\n\n          if (types.isType(identifier)) {\n            this.emitToken('TYPE', identifier)\n          } else {\n            this.emitToken('IDENTIFIER', identifier)\n          }\n          break\n        }\n\n        if (current === `'` || current === `\"`) {\n          let string = ''\n          while (!this.matches(`'`) && !this.matches(`\"`)) {\n            string += this.consume()\n          }\n          this.emitToken('STRING', string)\n          break\n        }\n\n        this.report(`Unexpected character \"${current}\"`)\n    }\n  }\n\n  /**\n   * Push a token to `Scanner.tokens`\n   *\n   * @param {string} type The token type\n   * @param {string?} value The token value\n   * @return {void}\n   */\n  emitToken (type, value) {\n    let token = { type }\n    if (value) token.value = value\n\n    this.tokens.push(token)\n  }\n\n  /**\n   * Get the current character and increase the cursor by 1\n   *\n   * @return {string}\n   */\n  consume () {\n    this.cursor++\n\n    return this.source[this.cursor - 1]\n  }\n\n  /**\n   * Get the character under the cursor without consuming it.\n   *\n   * @return {string}\n   */\n  peek () {\n    return this.source[this.cursor]\n  }\n\n  /**\n   * Checks if the next character matches an expected one.\n   *\n   * Increases the cursor by 1 if the character matches.\n   *\n   * @param {string} expected The character to expect\n   * @return {boolean} True if the next character matches, otherise false\n   */\n  matches (expected) {\n    if (this.eof()) return false\n    if (this.peek() !== expected) {\n      return false\n    }\n\n    this.cursor++\n    return true\n  }\n\n  /**\n   * Scans source and returns a list of tokens.\n   *\n   * @return {Array<Token>}\n   */\n  async scan () {\n    while (!this.eof()) {\n      this.scanToken()\n    }\n\n    if (this.state === SCANNER_STATE.ERROR) {\n      console.error(`Errors encountered while scanning source`)\n      return\n    }\n\n    return this.tokens\n  }\n\n  /**\n   * Returns true if we've reached the end of source, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof () {\n    return this.cursor >= this.source.length\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the scanner state to `SCANNER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report (error) {\n    this.state = SCANNER_STATE.ERROR\n    console.error(\n      `Error (${this.cursor}): ${error}`\n    )\n  }\n}\n\n/**\n * Scans source and returns a list of tokens.\n *\n * @memberof radspec/scanner\n * @param  {string} source\n * @return {Array<Token>}\n */\nexport function scan (source) {\n  return new Scanner(source).scan()\n}\n"],"file":"index.js"}},"error":null,"hash":"ab727e01c74e15c445680630a40b2fde","cacheData":{"env":{}}}