{"id":"node_modules/@1hive/radspec/dist/evaluator/index.js","dependencies":[{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/evaluator/index.js.map","includedInParent":true,"mtime":1682941398899},{"name":"/home/agevi/chui Organisation/pennify-aragon/package.json","includedInParent":true,"mtime":1682968105152},{"name":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/package.json","includedInParent":true,"mtime":1682941398899},{"name":"@babel/runtime/helpers/interopRequireDefault","loc":{"line":1,"column":48,"index":48},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/evaluator/index.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@babel/runtime/helpers/interopRequireDefault.js"},{"name":"ethers","loc":{"line":1,"column":222,"index":222},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/evaluator/index.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/ethers/lib.esm/index.js"},{"name":"../types","loc":{"line":1,"column":270,"index":270},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/evaluator/index.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/types/index.js"},{"name":"../helpers/HelperManager","loc":{"line":1,"column":329,"index":329},"parent":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/evaluator/index.js","resolved":"/home/agevi/chui Organisation/pennify-aragon/node_modules/@1hive/radspec/dist/helpers/HelperManager.js"}],"generated":{"js":"\"use strict\";var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Evaluator=void 0,exports.evaluate=evaluate;var _ethers=require(\"ethers\"),_types=_interopRequireDefault(require(\"../types\")),_HelperManager=_interopRequireDefault(require(\"../helpers/HelperManager\"));/**\n * @module radspec/evaluator\n */ /**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */class TypedValue{constructor(type,value){if(this.type=type,this.value=value,_types.default.isInteger(this.type)&&!_ethers.BigNumber.isBigNumber(this.value)&&(this.value=_ethers.BigNumber.from(this.value)),\"address\"===this.type){if(!_ethers.utils.isAddress(this.value))throw new Error(`Invalid address \"${this.value}\"`);this.value=_ethers.utils.getAddress(this.value)}}/**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */toString(){return this.value.toString()}}/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Object} options.availableFunctions Available function signatures\n * @param {?ethersProvider.Provider} options.provider EIP 1193 provider\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */class Evaluator{constructor(ast,bindings){let{availableHelpers={},availableFunctions={},provider,from,to,value=\"0\",data}=2<arguments.length&&arguments[2]!==void 0?arguments[2]:{};this.ast=ast,this.bindings=bindings,this.provider=provider||ethers.getDefaultProvider(),this.from=from&&new TypedValue(\"address\",from),this.to=to&&new TypedValue(\"address\",to),this.value=new TypedValue(\"uint\",_ethers.BigNumber.from(value)),this.data=data&&new TypedValue(\"bytes\",data),this.helpers=new _HelperManager.default(availableHelpers),this.functions=availableFunctions}/**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */async evaluateNodes(nodes){return Promise.all(nodes.map(this.evaluateNode.bind(this)))}/**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<string>}\n   */async evaluateNode(node){var _Mathceil=Math.ceil;if(\"ExpressionStatement\"===node.type)return(await this.evaluateNodes(node.body)).join(\" \");if(\"GroupedExpression\"===node.type)return this.evaluateNode(node.body);if(\"MonologueStatement\"===node.type)return new TypedValue(\"string\",node.value);if(\"StringLiteral\"===node.type)return new TypedValue(\"string\",node.value||\"\");if(\"NumberLiteral\"===node.type)return new TypedValue(\"int256\",node.value);if(\"BytesLiteral\"===node.type){const length=_Mathceil((node.value.length-2)/2);return 32<length&&this.panic(\"Byte literal represents more than 32 bytes\"),new TypedValue(`bytes${length}`,node.value)}if(\"BoolLiteral\"===node.type)return new TypedValue(\"bool\",\"true\"===node.value);if(\"BinaryExpression\"===node.type){const left=await this.evaluateNode(node.left),right=await this.evaluateNode(node.right);// String concatenation\nif((\"string\"===left.type||\"string\"===right.type)&&\"PLUS\"===node.operator)return new TypedValue(\"string\",left.value.toString()+right.value.toString());// TODO Additionally check that the type is signed if subtracting\nswitch(_types.default.isInteger(left.type)&&_types.default.isInteger(right.type)||this.panic(`Cannot evaluate binary expression \"${node.operator}\" for non-integer types \"${left.type}\" and \"${right.type}\"`),node.operator){case\"PLUS\":return new TypedValue(\"int256\",left.value.add(right.value));case\"MINUS\":return new TypedValue(\"int256\",left.value.sub(right.value));case\"STAR\":return new TypedValue(\"int256\",left.value.mul(right.value));case\"POWER\":return new TypedValue(\"int256\",left.value.pow(right.value));case\"SLASH\":return new TypedValue(\"int256\",left.value.div(right.value));case\"MODULO\":return new TypedValue(\"int256\",left.value.mod(right.value));default:this.panic(`Undefined binary operator \"${node.operator}\"`);}}if(\"ComparisonExpression\"===node.type){const left=await this.evaluateNode(node.left),right=await this.evaluateNode(node.right);let leftValue=left.value,rightValue=right.value;const bothTypesAddress=(left,right)=>// isAddress is true if type is address or bytes with size less than 20\n_types.default.isAddress(left.type)&&_types.default.isAddress(right.type),bothTypesBytes=(left,right)=>_types.default.types.bytes.isType(left.type)&&_types.default.types.bytes.isType(right.type);switch(bothTypesAddress(left,right)||bothTypesBytes(left,right)?(leftValue=_ethers.BigNumber.from(leftValue),rightValue=_ethers.BigNumber.from(rightValue)):(!_types.default.isInteger(left.type)||!_types.default.isInteger(right.type))&&this.panic(`Cannot evaluate binary expression \"${node.operator}\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${right.type}\"`),node.operator){case\"GREATER\":return new TypedValue(\"bool\",leftValue.gt(rightValue));case\"GREATER_EQUAL\":return new TypedValue(\"bool\",leftValue.gte(rightValue));case\"LESS\":return new TypedValue(\"bool\",leftValue.lt(rightValue));case\"LESS_EQUAL\":return new TypedValue(\"bool\",leftValue.lte(rightValue));case\"EQUAL_EQUAL\":return new TypedValue(\"bool\",leftValue.eq(rightValue));case\"BANG_EQUAL\":return new TypedValue(\"bool\",!leftValue.eq(rightValue));}}if(\"TernaryExpression\"===node.type)return(await this.evaluateNode(node.predicate)).value?this.evaluateNode(node.left):this.evaluateNode(node.right);if(\"DefaultExpression\"===node.type){const left=await this.evaluateNode(node.left);let leftFalsey;return leftFalsey=_types.default.isInteger(left.type)?left.value.isZero():\"address\"===left.type||left.type.startsWith(\"bytes\")?/^0x[0]*$/.test(left.value):!left.value,leftFalsey?this.evaluateNode(node.right):left}if(\"CallExpression\"===node.type){let target;// Inject self\ntarget=\"Identifier\"===node.target.type&&\"self\"===node.target.value?this.to:await this.evaluateNode(node.target),\"bytes20\"!==target.type&&\"address\"!==target.type?this.panic(\"Target of call expression was not an address\"):!_ethers.utils.isAddress(target.value)&&this.panic(`Invalid address \"${this.value}\"`);const inputs=await this.evaluateNodes(node.inputs),outputs=node.outputs,selectedReturnValueIndex=outputs.findIndex(output=>output.selected);-1===selectedReturnValueIndex&&this.panic(`No selected return value for function call \"${node.callee}\"`);const returnType=outputs[selectedReturnValueIndex].type,abi=[{name:node.callee,type:\"function\",inputs:inputs.map(_ref=>{let{type}=_ref;return{type}}),outputs:outputs.map(_ref2=>{let{type}=_ref2;return{type}}),stateMutability:\"view\"}],ethersInterface=new _ethers.utils.Interface(abi),txData=ethersInterface.encodeFunctionData(node.callee,inputs.map(input=>input.value.toString())),data=await this.provider.call({to:target.value,data:txData}),decodeData=ethersInterface.decodeFunctionResult(node.callee,data);return new TypedValue(returnType,decodeData[selectedReturnValueIndex])}if(\"HelperFunction\"===node.type){const helperName=node.name;this.helpers.exists(helperName)||this.panic(`${helperName} helper function is not defined`);const inputs=await this.evaluateNodes(node.inputs),result=await this.helpers.execute(helperName,inputs,{provider:this.provider,evaluator:this,functions:this.functions});return new TypedValue(result.type,result.value)}if(\"PropertyAccessExpression\"===node.type&&\"msg\"===node.target.value){if(\"value\"===node.property)return this.value;if(\"sender\"===node.property)return this.from;if(\"data\"===node.property)return this.data;this.panic(`Expecting value, sender or data property for msg identifier but got: ${node.property}`)}if(\"Identifier\"===node.type){if(\"self\"===node.value)return this.to;this.bindings.hasOwnProperty(node.value)||this.panic(`Undefined binding \"${node.value}\"`);const binding=this.bindings[node.value];return new TypedValue(binding.type,binding.value)}}/**\n   * Evaluate the entire AST.\n   *\n   * @return {string}\n   */async evaluate(){return this.evaluateNodes(this.ast.body).then(evaluatedNodes=>evaluatedNodes.join(\"\"))}/**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */panic(msg){throw new Error(`Error: ${msg}`)}}/**\n * Evaluates an AST\n *\n * @memberof radspec/evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Object} options.availableFunctions Available function signatures\n * @param {?ethersProvider.Provider} options.provider EIP 1193 provider\n * @param {?string} options.to The destination address for this expression's transaction\n * @return {string}\n */exports.Evaluator=Evaluator;function evaluate(ast,bindings,options){return new Evaluator(ast,bindings,options).evaluate()}\n"},"sourceMaps":{"js":{"version":3,"sources":["../../src/evaluator/index.js"],"names":["TypedValue","constructor","type","value","types","isInteger","BigNumber","isBigNumber","from","ethersUtils","isAddress","Error","getAddress","toString","Evaluator","ast","bindings","availableHelpers","availableFunctions","provider","to","data","ethers","getDefaultProvider","helpers","HelperManager","functions","evaluateNodes","nodes","Promise","all","map","evaluateNode","bind","node","Math","ceil","body","join","length","panic","left","right","operator","add","sub","mul","pow","div","mod","leftValue","rightValue","bothTypesAddress","bothTypesBytes","bytes","isType","gt","gte","lt","lte","eq","predicate","leftFalsey","isZero","startsWith","test","target","inputs","outputs","selectedReturnValueIndex","findIndex","output","selected","callee","returnType","abi","name","stateMutability","ethersInterface","Interface","txData","encodeFunctionData","input","call","decodeData","decodeFunctionResult","helperName","exists","result","execute","evaluator","property","hasOwnProperty","binding","evaluate","then","evaluatedNodes","msg","options"],"mappings":"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","sourcesContent":["/**\n * @module radspec/evaluator\n */\n\nimport { BigNumber, providers as ethersProvider, utils as ethersUtils } from 'ethers'\n\nimport types from '../types'\nimport HelperManager from '../helpers/HelperManager'\n\n/**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */\nclass TypedValue {\n  constructor (type, value) {\n    this.type = type\n    this.value = value\n\n    if (types.isInteger(this.type) && !BigNumber.isBigNumber(this.value)) {\n      this.value = BigNumber.from(this.value)\n    }\n\n    if (this.type === 'address') {\n      if (!ethersUtils.isAddress(this.value)) {\n        throw new Error(`Invalid address \"${this.value}\"`)\n      }\n      this.value = ethersUtils.getAddress(this.value)\n    }\n  }\n\n  /**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */\n  toString () {\n    return this.value.toString()\n  }\n}\n\n/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Object} options.availableFunctions Available function signatures\n * @param {?ethersProvider.Provider} options.provider EIP 1193 provider\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */\nexport class Evaluator {\n  constructor (\n    ast,\n    bindings,\n    { availableHelpers = {}, availableFunctions = {}, provider, from, to, value = '0', data } = {}\n  ) {\n    this.ast = ast\n    this.bindings = bindings\n    this.provider =\n      provider || ethers.getDefaultProvider()\n    this.from = from && new TypedValue('address', from)\n    this.to = to && new TypedValue('address', to)\n    this.value = new TypedValue('uint', BigNumber.from(value))\n    this.data = data && new TypedValue('bytes', data)\n    this.helpers = new HelperManager(availableHelpers)\n    this.functions = availableFunctions\n  }\n\n  /**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */\n  async evaluateNodes (nodes) {\n    return Promise.all(nodes.map(this.evaluateNode.bind(this)))\n  }\n\n  /**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<string>}\n   */\n  async evaluateNode (node) {\n    if (node.type === 'ExpressionStatement') {\n      return (await this.evaluateNodes(node.body)).join(' ')\n    }\n\n    if (node.type === 'GroupedExpression') {\n      return this.evaluateNode(node.body)\n    }\n\n    if (node.type === 'MonologueStatement') {\n      return new TypedValue('string', node.value)\n    }\n\n    if (node.type === 'StringLiteral') {\n      return new TypedValue('string', node.value || '')\n    }\n\n    if (node.type === 'NumberLiteral') {\n      return new TypedValue('int256', node.value)\n    }\n\n    if (node.type === 'BytesLiteral') {\n      const length = Math.ceil((node.value.length - 2) / 2)\n      if (length > 32) {\n        this.panic('Byte literal represents more than 32 bytes')\n      }\n\n      return new TypedValue(`bytes${length}`, node.value)\n    }\n\n    if (node.type === 'BoolLiteral') {\n      return new TypedValue('bool', node.value === 'true')\n    }\n\n    if (node.type === 'BinaryExpression') {\n      const left = await this.evaluateNode(node.left)\n      const right = await this.evaluateNode(node.right)\n\n      // String concatenation\n      if (\n        (left.type === 'string' || right.type === 'string') &&\n        node.operator === 'PLUS'\n      ) {\n        return new TypedValue(\n          'string',\n          left.value.toString() + right.value.toString()\n        )\n      }\n\n      // TODO Additionally check that the type is signed if subtracting\n      if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${node.operator}\" for non-integer types \"${left.type}\" and \"${right.type}\"`\n        )\n      }\n\n      switch (node.operator) {\n        case 'PLUS':\n          return new TypedValue('int256', left.value.add(right.value))\n        case 'MINUS':\n          return new TypedValue('int256', left.value.sub(right.value))\n        case 'STAR':\n          return new TypedValue('int256', left.value.mul(right.value))\n        case 'POWER':\n          return new TypedValue('int256', left.value.pow(right.value))\n        case 'SLASH':\n          return new TypedValue('int256', left.value.div(right.value))\n        case 'MODULO':\n          return new TypedValue('int256', left.value.mod(right.value))\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`)\n      }\n    }\n\n    if (node.type === 'ComparisonExpression') {\n      const left = await this.evaluateNode(node.left)\n      const right = await this.evaluateNode(node.right)\n\n      let leftValue = left.value\n      let rightValue = right.value\n\n      const bothTypesAddress = (left, right) =>\n        // isAddress is true if type is address or bytes with size less than 20\n        types.isAddress(left.type) && types.isAddress(right.type)\n\n      const bothTypesBytes = (left, right) =>\n        types.types.bytes.isType(left.type) &&\n        types.types.bytes.isType(right.type)\n\n      // Conversion to BigNumber for comparison will happen if:\n      // - Both types are addresses or bytes of any size (can be different sizes)\n      // - If one of the types is an address and the other bytes with size less than 20\n      if (bothTypesAddress(left, right) || bothTypesBytes(left, right)) {\n        leftValue = BigNumber.from(leftValue)\n        rightValue = BigNumber.from(rightValue)\n      } else if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${node.operator}\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${right.type}\"`\n        )\n      }\n\n      switch (node.operator) {\n        case 'GREATER':\n          return new TypedValue('bool', leftValue.gt(rightValue))\n        case 'GREATER_EQUAL':\n          return new TypedValue('bool', leftValue.gte(rightValue))\n        case 'LESS':\n          return new TypedValue('bool', leftValue.lt(rightValue))\n        case 'LESS_EQUAL':\n          return new TypedValue('bool', leftValue.lte(rightValue))\n        case 'EQUAL_EQUAL':\n          return new TypedValue('bool', leftValue.eq(rightValue))\n        case 'BANG_EQUAL':\n          return new TypedValue('bool', !leftValue.eq(rightValue))\n      }\n    }\n\n    if (node.type === 'TernaryExpression') {\n      if ((await this.evaluateNode(node.predicate)).value) {\n        return this.evaluateNode(node.left)\n      }\n\n      return this.evaluateNode(node.right)\n    }\n\n    if (node.type === 'DefaultExpression') {\n      const left = await this.evaluateNode(node.left)\n      let leftFalsey\n\n      if (types.isInteger(left.type)) {\n        leftFalsey = left.value.isZero()\n      } else if (left.type === 'address' || left.type.startsWith('bytes')) {\n        leftFalsey = /^0x[0]*$/.test(left.value)\n      } else {\n        leftFalsey = !left.value\n      }\n\n      return leftFalsey ? this.evaluateNode(node.right) : left\n    }\n\n    if (node.type === 'CallExpression') {\n      let target\n\n      // Inject self\n      if (node.target.type === 'Identifier' && node.target.value === 'self') {\n        target = this.to\n      } else {\n        target = await this.evaluateNode(node.target)\n      }\n\n      if (target.type !== 'bytes20' && target.type !== 'address') {\n        this.panic('Target of call expression was not an address')\n      } else if (!ethersUtils.isAddress(target.value)) {\n        this.panic(`Invalid address \"${this.value}\"`)\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs)\n      const outputs = node.outputs\n      const selectedReturnValueIndex = outputs.findIndex(\n        (output) => output.selected\n      )\n      if (selectedReturnValueIndex === -1) {\n        this.panic(\n          `No selected return value for function call \"${node.callee}\"`\n        )\n      }\n      const returnType = outputs[selectedReturnValueIndex].type\n\n      const abi = [\n        {\n          name: node.callee,\n          type: 'function',\n          inputs: inputs.map(({ type }) => ({\n            type\n          })),\n          outputs: outputs.map(({ type }) => ({\n            type\n          })),\n          stateMutability: 'view'\n        }\n      ]\n      const ethersInterface = new ethersUtils.Interface(abi)\n\n      const txData = ethersInterface.encodeFunctionData(\n        node.callee,\n        inputs.map((input) => input.value.toString())\n      )\n\n      const data = await this.provider.call({\n        to: target.value,\n        data: txData\n      })\n\n      const decodeData = ethersInterface.decodeFunctionResult(node.callee, data)\n\n      return new TypedValue(returnType, decodeData[selectedReturnValueIndex])\n    }\n\n    if (node.type === 'HelperFunction') {\n      const helperName = node.name\n\n      if (!this.helpers.exists(helperName)) {\n        this.panic(`${helperName} helper function is not defined`)\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs)\n      const result = await this.helpers.execute(helperName, inputs, {\n        provider: this.provider,\n        evaluator: this,\n        functions: this.functions\n      })\n\n      return new TypedValue(result.type, result.value)\n    }\n\n    if (\n      node.type === 'PropertyAccessExpression' &&\n      node.target.value === 'msg'\n    ) {\n      if (node.property === 'value') {\n        return this.value\n      }\n\n      if (node.property === 'sender') {\n        return this.from\n      }\n\n      if (node.property === 'data') {\n        return this.data\n      }\n\n      this.panic(\n        `Expecting value, sender or data property for msg identifier but got: ${node.property}`\n      )\n    }\n\n    if (node.type === 'Identifier') {\n      if (node.value === 'self') {\n        return this.to\n      }\n\n      if (!this.bindings.hasOwnProperty(node.value)) {\n        this.panic(`Undefined binding \"${node.value}\"`)\n      }\n\n      const binding = this.bindings[node.value]\n      return new TypedValue(binding.type, binding.value)\n    }\n  }\n\n  /**\n   * Evaluate the entire AST.\n   *\n   * @return {string}\n   */\n  async evaluate () {\n    return this.evaluateNodes(this.ast.body).then((evaluatedNodes) =>\n      evaluatedNodes.join('')\n    )\n  }\n\n  /**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */\n  panic (msg) {\n    throw new Error(`Error: ${msg}`)\n  }\n}\n\n/**\n * Evaluates an AST\n *\n * @memberof radspec/evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Object} options.availableFunctions Available function signatures\n * @param {?ethersProvider.Provider} options.provider EIP 1193 provider\n * @param {?string} options.to The destination address for this expression's transaction\n * @return {string}\n */\nexport function evaluate (ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate()\n}\n"],"file":"index.js"}},"error":null,"hash":"e28ce9627e1fbd6f6fffff9f3b5c875c","cacheData":{"env":{}}}